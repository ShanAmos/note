springboot:
mybatis-generator-maven-plugin插件：用于自动生成mapper和pojo
1. pom.xml中添加插件依赖
<plugin>
                    <groupId>org.mybatis.generator</groupId>
                    <artifactId>mybatis-generator-maven-plugin</artifactId>
                    <version>1.3.2</version>
                    <dependencies>
                        <dependency>
                            <groupId>mysql</groupId>
                            <artifactId>mysql-connector-java</artifactId>
                            <version>5.1.35</version>
                        </dependency>
                    </dependencies>
                    <configuration>
                         <!--配置文件的路径-->
                         <configurationFile>${basedir}/src/main/resources/generatorConfig.xml</configurationFile> 
                        <overwrite>true</overwrite>
                    </configuration>
                </plugin>

2. 添加jar依赖
<dependency>
		    <groupId>org.mybatis.generator</groupId>
		    <artifactId>mybatis-generator-core</artifactId>
		    <version>1.3.5</version>
		</dependency>
		<!-- 分页 -->
			<dependency>
			    <groupId>com.github.pagehelper</groupId>
			    <artifactId>pagehelper-spring-boot-starter</artifactId>
			    <version>1.1.1</version>
			</dependency>
3. 新建generatorConfig.xml，配置需要生成的文件位置
4. 执行命令 mvn mybatis-generator:generate自动生成文件

springboot热部署：spring-boot-devtools，其深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），
另一个ClassLoader加载会更改的类，称为  restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，
重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间（5秒以内）
1. pom.xml中添加依赖
<!--支持热启动jar包-->
<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-devtools</artifactId>
      <version>${spring-boot.version}</version>
      <optional>true</optional>
      <!-- optional=true,依赖不会传递，该项目依赖devtools；之后依赖该项目的项目如果想要使用devtools，需要重新引入 -->
</dependency>
<plugin>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-maven-plugin</artifactId>
      <configuration>
          <fork>true</fork>
       </configuration>
       <dependencies>
       <!-- spring热部署-->
       <!-- https://mvnrepository.com/artifact/org.springframework/springloaded -->
           <dependency>
              <groupId>org.springframework</groupId>
              <artifactId>springloaded</artifactId>
              <version>1.2.6.RELEASE</version>
          </dependency>
       </dependencies>
</plugin>

2. applitaion.yaml中配置（可选）
spring:
    devtools:
        restart:
            #热部署生效
          enabled: true
            #设置重启的目录
            #additional-paths: src/main/java
            #classpath目录下的WEB-INF文件夹内容修改不重启
          exclude: WEB-INF/**

springboot使用自定义的properties
1. 在application.properties配置：
com.neo.title=纯洁的微笑
com.neo.description=分享生活和技术

2. 自定义配置类：
@Component
public class NeoProperties {
    @Value("${com.neo.title}")
    private String title;
    @Value("${com.neo.description}")
    private String description;

    //省略getter settet方法

    }
    
 WebJars:我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，
 但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。
 那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理
 1. 加入依赖，如vue.js
 <dependency>
    <groupId>org.webjars.bower</groupId>
    <artifactId>vue</artifactId>
    <version>1.0.21</version>
</dependency>

2. 页面引入：
<link th:href="@{/webjars/bootstrap/3.3.6/dist/css/bootstrap.css}" rel="stylesheet"></link>

springboot中redis使用
1 引入redis启动器
<dependency>  
    <groupId>org.springframework.boot</groupId>  
    <artifactId>spring-boot-starter-redis</artifactId>  
</dependency> 

2. 添加properties配置
# REDIS (RedisProperties)
# Redis数据库索引（默认为0）
spring.redis.database=0  
# Redis服务器地址
spring.redis.host=192.168.0.58
# Redis服务器连接端口
spring.redis.port=6379  
# Redis服务器连接密码（默认为空）
spring.redis.password=  
# 连接池最大连接数（使用负值表示没有限制）
spring.redis.pool.max-active=8  
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.pool.max-wait=-1  
# 连接池中的最大空闲连接
spring.redis.pool.max-idle=8  
# 连接池中的最小空闲连接
spring.redis.pool.min-idle=0  
# 连接超时时间（毫秒）
spring.redis.timeout=0 

3. 添加cache配置类（使用@Configuration和@Bean代替xml中配置<beans>和<bean>）
@Configuration
@EnableCaching
public class RedisConfig extends CachingConfigurerSupport{
    
    @Bean
    public KeyGenerator keyGenerator() {
        return new KeyGenerator() {
            @Override
            public Object generate(Object target, Method method, Object... params) {
                StringBuilder sb = new StringBuilder();
                sb.append(target.getClass().getName());
                sb.append(method.getName());
                for (Object obj : params) {
                    sb.append(obj.toString());
                }
                return sb.toString();
            }
        };
    }

    @SuppressWarnings("rawtypes")
    @Bean
    public CacheManager cacheManager(RedisTemplate redisTemplate) {
        RedisCacheManager rcm = new RedisCacheManager(redisTemplate);
        //设置缓存过期时间
        //rcm.setDefaultExpiration(60);//秒
        return rcm;
    }
    
    @Bean
    public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory factory) {
        StringRedisTemplate template = new StringRedisTemplate(factory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }

}

4. 手动方式使用缓存
   @RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(Application.class)
public class TestRedis {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    
    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    public void test() throws Exception {
        stringRedisTemplate.opsForValue().set("aaa", "111");
        Assert.assertEquals("111", stringRedisTemplate.opsForValue().get("aaa"));
    }
    
    @Test
    public void testObj() throws Exception {
        User user=new User("aa@126.com", "aa", "aa123456", "aa","123");
        ValueOperations<String, User> operations=redisTemplate.opsForValue();
        operations.set("com.neox", user);
        operations.set("com.neo.f", user,1,TimeUnit.SECONDS);
        Thread.sleep(1000);
        //redisTemplate.delete("com.neo.f");
        boolean exists=redisTemplate.hasKey("com.neo.f");
        if(exists){
            System.out.println("exists is true");
        }else{
            System.out.println("exists is false");
        }
       // Assert.assertEquals("aa", operations.get("com.neo.f").getUserName());
    }
}

5. 查找数据库时，自动使用缓存（主要是@cacheable注解，value是redis的key）
@RequestMapping("/getUser")
@Cacheable(value="user-key")
public User getUser() {
    User user=userRepository.findByUserName("aa");
    System.out.println("若下面没出现“无缓存的时候调用”字样且能打印出数据表示测试成功");  
    return user;
}
  
分布式系统中session托管到缓存实现session共享
1. 引入依赖
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
</dependency>

2. session配置
@Configuration
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 86400*30)
//设置sessions失效时间，引入Redis Session之后，原Boot的server.session.timeout属性不再生效
public class SessionConfig {
}

3. 在另一个项目中也配置上面两步，实现session共享
